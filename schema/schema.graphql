type ActiveRecording {
  continuous: Boolean!
  "Archive the specified Flight Recording"
  doArchive: ArchivedRecording
  "Delete the specified Flight Recording"
  doDelete: ActiveRecording
  "Updates the metadata labels for an existing Flight Recording."
  doPutMetadata(metadataInput: MetadataLabelsInput): ActiveRecording
  "Stop the specified Flight Recording"
  doStop: ActiveRecording
  "URL for GET request to retrieve the JFR binary file content of this recording"
  downloadUrl: String
  duration: BigInteger!
  id: BigInteger
  maxAge: BigInteger!
  maxSize: BigInteger!
  metadata: Metadata!
  name: String!
  remoteId: BigInteger!
  "URL for GET request to retrieve a JSON formatted Automated Analysis Report of this recording"
  reportUrl: String
  startTime: BigInteger!
  state: RecordingState!
  target: Target!
  toDisk: Boolean!
}

type ActiveRecordings {
  aggregate: AggregateInfo!
  data: [ActiveRecording]!
}

type AggregateInfo {
  "The number of elements in this collection"
  count: BigInteger!
  "The sum of sizes of elements in this collection, or 0 if not applicable"
  size: BigInteger!
}

type Annotations {
  cryostat(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]
  platform(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]
}

type ArchivedRecording {
  archivedTime: BigInteger!
  doDelete: ArchivedRecording!
  doPutMetadata(metadataInput: MetadataLabelsInput): ArchivedRecording!
  downloadUrl: String
  jvmId: String
  metadata: Metadata
  name: String
  reportUrl: String
  size: BigInteger!
}

type ArchivedRecordings {
  aggregate: AggregateInfo!
  data: [ArchivedRecording]!
}

type DiscoveryNode {
  children: [DiscoveryNode]
  "Get target nodes that are descendants of this node. That is, get the set of leaf nodes from anywhere below this node's subtree."
  descendantTargets(filter: DiscoveryNodeFilterInput): [DiscoveryNode]
  id: BigInteger
  labels(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]!
  name: String!
  nodeType: String!
  target: Target
}

type Entry_String_String {
  key: String
  value: String
}

type MBeanMetrics {
  jvmId: String
  memory: MemoryMetrics
  os: OperatingSystemMetrics
  runtime: RuntimeMetrics
  thread: ThreadMetrics
}

type MemoryMetrics {
  freeHeapMemory: BigInteger!
  freeNonHeapMemory: BigInteger!
  heapMemoryUsage: MemoryUtilization
  heapMemoryUsagePercent: Float!
  nonHeapMemoryUsage: MemoryUtilization
  objectPendingFinalizationCount: BigInteger!
  verbose: Boolean!
}

type MemoryUtilization {
  committed: BigInteger!
  init: BigInteger!
  max: BigInteger!
  used: BigInteger!
}

type Metadata {
  "ISO-8601"
  expiry: DateTime
  labels(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]
}

"Mutation root"
type Mutation {
  "Archive an existing Flight Recording matching the given filter, on all Targets under the subtrees of the discovery nodes matching the given filter"
  archiveRecording(nodes: DiscoveryNodeFilterInput!, recordings: ActiveRecordingsFilterInput): [ArchivedRecording]
  "Start a new Flight Recording on all Targets under the subtrees of the discovery nodes matching the given filter"
  createRecording(nodes: DiscoveryNodeFilterInput!, recording: RecordingSettingsInput!): [ActiveRecording]
  "Create a Flight Recorder Snapshot on all Targets under the subtrees of the discovery nodes matching the given filter"
  createSnapshot(nodes: DiscoveryNodeFilterInput!): [ActiveRecording]
  "Delete an existing Flight Recording matching the given filter, on all Targets under the subtrees of the discovery nodes matching the given filter"
  deleteRecording(nodes: DiscoveryNodeFilterInput!, recordings: ActiveRecordingsFilterInput): [ActiveRecording]
  "Stop an existing Flight Recording matching the given filter, on all Targets under the subtrees of the discovery nodes matching the given filter"
  stopRecording(nodes: DiscoveryNodeFilterInput!, recordings: ActiveRecordingsFilterInput): [ActiveRecording]
}

type OperatingSystemMetrics {
  arch: String
  availableProcessors: Int!
  committedVirtualMemorySize: BigInteger!
  freePhysicalMemorySize: BigInteger!
  freeSwapSpaceSize: BigInteger!
  name: String
  processCpuLoad: Float!
  processCpuTime: BigInteger!
  systemCpuLoad: Float!
  systemLoadAverage: Float!
  totalPhysicalMemorySize: BigInteger!
  totalSwapSpaceSize: BigInteger!
  version: String
}

"Query root"
type Query {
  archivedRecordings(filter: ArchivedRecordingsFilterInput): ArchivedRecordings
  "Get all environment nodes in the discovery tree with optional filtering"
  environmentNodes(filter: DiscoveryNodeFilterInput): [DiscoveryNode]
  "Get the root target discovery node"
  rootNode: DiscoveryNode
  "Get the Target discovery nodes, i.e. the leaf nodes of the discovery tree"
  targetNodes(filter: DiscoveryNodeFilterInput): [DiscoveryNode]
}

type Recordings {
  active(filter: ActiveRecordingsFilterInput): ActiveRecordings
  archived(filter: ArchivedRecordingsFilterInput): ArchivedRecordings
}

type RuntimeMetrics {
  bootClassPath: String
  bootClassPathSupported: Boolean!
  classPath: String
  inputArguments: [String]
  libraryPath: String
  managementSpecVersion: String
  name: String
  specName: String
  specVendor: String
  specVersion: String
  startTime: BigInteger!
  systemProperties(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]
  uptime: BigInteger!
  vmName: String
  vmVendor: String
  vmVersion: String
}

type Target {
  activeRecordings(filter: ActiveRecordingsFilterInput): ActiveRecordings
  agent: Boolean!
  alias: String!
  annotations: Annotations!
  archivedRecordings(filter: ArchivedRecordingsFilterInput): ArchivedRecordings
  connectUrl: String!
  "Create a new Flight Recorder Snapshot on the specified Target"
  doSnapshot: ActiveRecording
  "Start a new Flight Recording on the specified Target"
  doStartRecording(recording: RecordingSettingsInput!): ActiveRecording
  id: BigInteger
  jvmId: String
  labels(
    "Get entry/entries for a certain key/s"
    key: [String]
  ): [Entry_String_String]!
  "Get live MBean metrics snapshot from the specified Target"
  mbeanMetrics: MBeanMetrics
  "Get the active and archived recordings belonging to this target"
  recordings: Recordings
}

type ThreadMetrics {
  allThreadIds: [BigInteger!]
  currentThreadCpuTime: BigInteger!
  currentThreadCpuTimeSupported: Boolean!
  currentThreadUserTime: BigInteger!
  daemonThreadCount: Int!
  objectMonitorUsageSupported: Boolean!
  peakThreadCount: Int!
  synchronizerUsageSupported: Boolean!
  threadContentionMonitoringEnabled: Boolean!
  threadContentionMonitoringSupported: Boolean!
  threadCount: Int!
  threadCpuTimeEnabled: Boolean!
  threadCpuTimeSupported: Boolean!
  totalStartedThreadCount: BigInteger!
}

"Running state of an active Flight Recording"
enum RecordingState {
  "CLOSED"
  CLOSED
  "DELAYED"
  DELAYED
  "NEW"
  NEW
  "RUNNING"
  RUNNING
  "STOPPED"
  STOPPED
}

input ActiveRecordingsFilterInput {
  continuous: Boolean
  durationMsGreaterThanEqual: BigInteger
  durationMsLessThanEqual: BigInteger
  labels: [String]
  name: String
  names: [String]
  startTimeMsAfterEqual: BigInteger
  startTimeMsBeforeEqual: BigInteger
  state: RecordingState
  toDisk: Boolean
}

input ArchivedRecordingsFilterInput {
  archivedTimeAfterEqual: BigInteger
  archivedTimeBeforeEqual: BigInteger
  labels: [String]
  name: String
  names: [String]
  sizeBytesGreaterThanEqual: BigInteger
  sizeBytesLessThanEqual: BigInteger
  sourceTarget: String
}

input DiscoveryNodeFilterInput {
  annotations: [String]
  id: BigInteger
  ids: [BigInteger]
  labels: [String]
  name: String
  names: [String]
  nodeTypes: [String]
  targetIds: [BigInteger]
}

input Entry_String_StringInput {
  key: String
  value: String
}

input MetadataLabelsInput {
  labels: [Entry_String_StringInput]
}

input RecordingMetadataInput {
  labels: [Entry_String_StringInput]
}

input RecordingSettingsInput {
  archiveOnStop: Boolean
  continuous: Boolean
  duration: BigInteger
  maxAge: BigInteger
  maxSize: BigInteger
  metadata: RecordingMetadataInput
  name: String!
  replace: String
  template: String!
  templateType: String!
  toDisk: Boolean
}
