-- Quarkus Quartz setup so that scheduled jobs, triggers, etc. are persisted in
-- the database and can survive application restarts
-- https://github.com/quartz-scheduler/quartz/blob/2a97f397949ec58fc980a661fd2930213b29d77b/quartz/src/main/resources/org/quartz/impl/jdbcjobstore/tables_postgres.sql
DROP TABLE IF EXISTS QRTZ_FIRED_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_PAUSED_TRIGGER_GRPS;
DROP TABLE IF EXISTS QRTZ_SCHEDULER_STATE;
DROP TABLE IF EXISTS QRTZ_LOCKS;
DROP TABLE IF EXISTS QRTZ_SIMPLE_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_CRON_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_SIMPROP_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_BLOB_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_TRIGGERS;
DROP TABLE IF EXISTS QRTZ_JOB_DETAILS;
DROP TABLE IF EXISTS QRTZ_CALENDARS;

CREATE TABLE QRTZ_JOB_DETAILS
(
  SCHED_NAME        VARCHAR(120) NOT NULL,
  JOB_NAME          VARCHAR(200) NOT NULL,
  JOB_GROUP         VARCHAR(200) NOT NULL,
  DESCRIPTION       VARCHAR(250) NULL,
  JOB_CLASS_NAME    VARCHAR(250) NOT NULL,
  IS_DURABLE        BOOL         NOT NULL,
  IS_NONCONCURRENT  BOOL         NOT NULL,
  IS_UPDATE_DATA    BOOL         NOT NULL,
  REQUESTS_RECOVERY BOOL         NOT NULL,
  JOB_DATA          BYTEA        NULL,
  PRIMARY KEY (SCHED_NAME, JOB_NAME, JOB_GROUP)
);

CREATE TABLE QRTZ_TRIGGERS
(
  SCHED_NAME     VARCHAR(120) NOT NULL,
  TRIGGER_NAME   VARCHAR(200) NOT NULL,
  TRIGGER_GROUP  VARCHAR(200) NOT NULL,
  JOB_NAME       VARCHAR(200) NOT NULL,
  JOB_GROUP      VARCHAR(200) NOT NULL,
  DESCRIPTION    VARCHAR(250) NULL,
  NEXT_FIRE_TIME BIGINT       NULL,
  PREV_FIRE_TIME BIGINT       NULL,
  PRIORITY       INTEGER      NULL,
  TRIGGER_STATE  VARCHAR(16)  NOT NULL,
  TRIGGER_TYPE   VARCHAR(8)   NOT NULL,
  START_TIME     BIGINT       NOT NULL,
  END_TIME       BIGINT       NULL,
  CALENDAR_NAME  VARCHAR(200) NULL,
  MISFIRE_INSTR  SMALLINT     NULL,
  JOB_DATA       BYTEA        NULL,
  PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME, JOB_NAME, JOB_GROUP)
  REFERENCES QRTZ_JOB_DETAILS (SCHED_NAME, JOB_NAME, JOB_GROUP)
);

CREATE TABLE QRTZ_SIMPLE_TRIGGERS
(
  SCHED_NAME      VARCHAR(120) NOT NULL,
  TRIGGER_NAME    VARCHAR(200) NOT NULL,
  TRIGGER_GROUP   VARCHAR(200) NOT NULL,
  REPEAT_COUNT    BIGINT       NOT NULL,
  REPEAT_INTERVAL BIGINT       NOT NULL,
  TIMES_TRIGGERED BIGINT       NOT NULL,
  PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CRON_TRIGGERS
(
  SCHED_NAME      VARCHAR(120) NOT NULL,
  TRIGGER_NAME    VARCHAR(200) NOT NULL,
  TRIGGER_GROUP   VARCHAR(200) NOT NULL,
  CRON_EXPRESSION VARCHAR(120) NOT NULL,
  TIME_ZONE_ID    VARCHAR(80),
  PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
);

CREATE TABLE QRTZ_SIMPROP_TRIGGERS
(
  SCHED_NAME    VARCHAR(120)   NOT NULL,
  TRIGGER_NAME  VARCHAR(200)   NOT NULL,
  TRIGGER_GROUP VARCHAR(200)   NOT NULL,
  STR_PROP_1    VARCHAR(512)   NULL,
  STR_PROP_2    VARCHAR(512)   NULL,
  STR_PROP_3    VARCHAR(512)   NULL,
  INT_PROP_1    INT            NULL,
  INT_PROP_2    INT            NULL,
  LONG_PROP_1   BIGINT         NULL,
  LONG_PROP_2   BIGINT         NULL,
  DEC_PROP_1    NUMERIC(13, 4) NULL,
  DEC_PROP_2    NUMERIC(13, 4) NULL,
  BOOL_PROP_1   BOOL           NULL,
  BOOL_PROP_2   BOOL           NULL,
  PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
);

CREATE TABLE QRTZ_BLOB_TRIGGERS
(
  SCHED_NAME    VARCHAR(120) NOT NULL,
  TRIGGER_NAME  VARCHAR(200) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  BLOB_DATA     BYTEA        NULL,
  PRIMARY KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP),
  FOREIGN KEY (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
  REFERENCES QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP)
);

CREATE TABLE QRTZ_CALENDARS
(
  SCHED_NAME    VARCHAR(120) NOT NULL,
  CALENDAR_NAME VARCHAR(200) NOT NULL,
  CALENDAR      BYTEA        NOT NULL,
  PRIMARY KEY (SCHED_NAME, CALENDAR_NAME)
);


CREATE TABLE QRTZ_PAUSED_TRIGGER_GRPS
(
  SCHED_NAME    VARCHAR(120) NOT NULL,
  TRIGGER_GROUP VARCHAR(200) NOT NULL,
  PRIMARY KEY (SCHED_NAME, TRIGGER_GROUP)
);

CREATE TABLE QRTZ_FIRED_TRIGGERS
(
  SCHED_NAME        VARCHAR(120) NOT NULL,
  ENTRY_ID          VARCHAR(95)  NOT NULL,
  TRIGGER_NAME      VARCHAR(200) NOT NULL,
  TRIGGER_GROUP     VARCHAR(200) NOT NULL,
  INSTANCE_NAME     VARCHAR(200) NOT NULL,
  FIRED_TIME        BIGINT       NOT NULL,
  SCHED_TIME        BIGINT       NOT NULL,
  PRIORITY          INTEGER      NOT NULL,
  STATE             VARCHAR(16)  NOT NULL,
  JOB_NAME          VARCHAR(200) NULL,
  JOB_GROUP         VARCHAR(200) NULL,
  IS_NONCONCURRENT  BOOL         NULL,
  REQUESTS_RECOVERY BOOL         NULL,
  PRIMARY KEY (SCHED_NAME, ENTRY_ID)
);

CREATE TABLE QRTZ_SCHEDULER_STATE
(
  SCHED_NAME        VARCHAR(120) NOT NULL,
  INSTANCE_NAME     VARCHAR(200) NOT NULL,
  LAST_CHECKIN_TIME BIGINT       NOT NULL,
  CHECKIN_INTERVAL  BIGINT       NOT NULL,
  PRIMARY KEY (SCHED_NAME, INSTANCE_NAME)
);

CREATE TABLE QRTZ_LOCKS
(
  SCHED_NAME VARCHAR(120) NOT NULL,
  LOCK_NAME  VARCHAR(40)  NOT NULL,
  PRIMARY KEY (SCHED_NAME, LOCK_NAME)
);

CREATE INDEX IDX_QRTZ_J_REQ_RECOVERY
  ON QRTZ_JOB_DETAILS (SCHED_NAME, REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_J_GRP
  ON QRTZ_JOB_DETAILS (SCHED_NAME, JOB_GROUP);

CREATE INDEX IDX_QRTZ_T_J
  ON QRTZ_TRIGGERS (SCHED_NAME, JOB_NAME, JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_JG
  ON QRTZ_TRIGGERS (SCHED_NAME, JOB_GROUP);
CREATE INDEX IDX_QRTZ_T_C
  ON QRTZ_TRIGGERS (SCHED_NAME, CALENDAR_NAME);
CREATE INDEX IDX_QRTZ_T_G
  ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_T_STATE
  ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_STATE
  ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP, TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_N_G_STATE
  ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_GROUP, TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NEXT_FIRE_TIME
  ON QRTZ_TRIGGERS (SCHED_NAME, NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST
  ON QRTZ_TRIGGERS (SCHED_NAME, TRIGGER_STATE, NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_MISFIRE
  ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE
  ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME, TRIGGER_STATE);
CREATE INDEX IDX_QRTZ_T_NFT_ST_MISFIRE_GRP
  ON QRTZ_TRIGGERS (SCHED_NAME, MISFIRE_INSTR, NEXT_FIRE_TIME, TRIGGER_GROUP, TRIGGER_STATE);

CREATE INDEX IDX_QRTZ_FT_TRIG_INST_NAME
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, INSTANCE_NAME);
CREATE INDEX IDX_QRTZ_FT_INST_JOB_REQ_RCVRY
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, INSTANCE_NAME, REQUESTS_RECOVERY);
CREATE INDEX IDX_QRTZ_FT_J_G
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, JOB_NAME, JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_JG
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, JOB_GROUP);
CREATE INDEX IDX_QRTZ_FT_T_G
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, TRIGGER_NAME, TRIGGER_GROUP);
CREATE INDEX IDX_QRTZ_FT_TG
  ON QRTZ_FIRED_TRIGGERS (SCHED_NAME, TRIGGER_GROUP);

-- Hibernate Envers audit tables
-- These tables track historical changes to @Audited entities
-- Standard Envers columns: REV (revision number), REVTYPE (0=add, 1=modify, 2=delete)

-- Revision info table - stores metadata about each revision
CREATE TABLE REVINFO (
    REV INTEGER NOT NULL,
    REVTSTMP BIGINT,
    username text check (char_length(username) < 64),
    PRIMARY KEY (REV)
);

CREATE SEQUENCE REVINFO_SEQ START WITH 1 INCREMENT BY 1;

-- Audit table for Target entity
CREATE TABLE Target_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    connectUrl BYTEA,
    alias text check (char_length(alias) < 255),
    jvmId text check (char_length(jvmId) < 255),
    labels TEXT,
    annotations TEXT,
    discoveryNode BIGINT,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for Rule entity
CREATE TABLE Rule_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    name text check (char_length(name) < 255),
    description text check (char_length(description) < 1024),
    matchExpression BIGINT,
    eventSpecifier text check (char_length(eventSpecifier) < 255),
    archivalPeriodSeconds INTEGER,
    initialDelaySeconds INTEGER,
    preservedArchives INTEGER,
    maxAgeSeconds INTEGER,
    maxSizeBytes INTEGER,
    metadata TEXT,
    enabled BOOLEAN,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for ActiveRecording entity
CREATE TABLE ActiveRecording_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    target_id BIGINT,
    name text check (char_length(name) < 64),
    remoteId BIGINT,
    state SMALLINT,
    duration BIGINT,
    startTime BIGINT,
    archiveOnStop BOOLEAN,
    continuous BOOLEAN,
    toDisk BOOLEAN,
    maxSize BIGINT,
    maxAge BIGINT,
    external BOOLEAN,
    metadata TEXT,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for MatchExpression entity
CREATE TABLE MatchExpression_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    script text check (char_length(script) < 1024),
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for DiscoveryPlugin entity
CREATE TABLE DiscoveryPlugin_AUD (
    id UUID NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    realm_id BIGINT,
    callback TEXT,
    credential_id BIGINT,
    builtin BOOLEAN,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for DiscoveryNode entity
CREATE TABLE DiscoveryNode_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    name text check (char_length(name) < 255),
    nodeType text check (char_length(nodeType) < 255),
    labels TEXT,
    parentNode BIGINT,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Audit table for Credential entity
CREATE TABLE Credential_AUD (
    id BIGINT NOT NULL,
    REV INTEGER NOT NULL,
    REVTYPE SMALLINT,
    matchExpression BIGINT,
    username BYTEA,
    password BYTEA,
    PRIMARY KEY (id, REV),
    FOREIGN KEY (REV) REFERENCES REVINFO (REV)
);

-- Indexes for audit tables to improve query performance
-- These indexes support common audit queries:
-- - Finding all revisions of a specific entity (by entity id)
-- - Finding all changes in a specific revision (by REV)
-- - Filtering by operation type (by REVTYPE: 0=add, 1=modify, 2=delete)

CREATE INDEX IDX_TARGET_AUD_ID ON Target_AUD (id);
CREATE INDEX IDX_TARGET_AUD_REV ON Target_AUD (REV);
CREATE INDEX IDX_TARGET_AUD_REVTYPE ON Target_AUD (REVTYPE);

CREATE INDEX IDX_RULE_AUD_ID ON Rule_AUD (id);
CREATE INDEX IDX_RULE_AUD_REV ON Rule_AUD (REV);
CREATE INDEX IDX_RULE_AUD_REVTYPE ON Rule_AUD (REVTYPE);

CREATE INDEX IDX_ACTIVERECORDING_AUD_ID ON ActiveRecording_AUD (id);
CREATE INDEX IDX_ACTIVERECORDING_AUD_REV ON ActiveRecording_AUD (REV);
CREATE INDEX IDX_ACTIVERECORDING_AUD_REVTYPE ON ActiveRecording_AUD (REVTYPE);

CREATE INDEX IDX_MATCHEXPRESSION_AUD_ID ON MatchExpression_AUD (id);
CREATE INDEX IDX_MATCHEXPRESSION_AUD_REV ON MatchExpression_AUD (REV);
CREATE INDEX IDX_MATCHEXPRESSION_AUD_REVTYPE ON MatchExpression_AUD (REVTYPE);

CREATE INDEX IDX_DISCOVERYPLUGIN_AUD_ID ON DiscoveryPlugin_AUD (id);
CREATE INDEX IDX_DISCOVERYPLUGIN_AUD_REV ON DiscoveryPlugin_AUD (REV);
CREATE INDEX IDX_DISCOVERYPLUGIN_AUD_REVTYPE ON DiscoveryPlugin_AUD (REVTYPE);

CREATE INDEX IDX_DISCOVERYNODE_AUD_ID ON DiscoveryNode_AUD (id);
CREATE INDEX IDX_DISCOVERYNODE_AUD_REV ON DiscoveryNode_AUD (REV);
CREATE INDEX IDX_DISCOVERYNODE_AUD_REVTYPE ON DiscoveryNode_AUD (REVTYPE);

CREATE INDEX IDX_CREDENTIAL_AUD_ID ON Credential_AUD (id);
CREATE INDEX IDX_CREDENTIAL_AUD_REV ON Credential_AUD (REV);
CREATE INDEX IDX_CREDENTIAL_AUD_REVTYPE ON Credential_AUD (REVTYPE);

--

COMMIT;
